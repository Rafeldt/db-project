<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Database Visualization</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding: 12px 14px; border-bottom: 1px solid rgba(127,127,127,.25); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header h1 { font-size: 16px; margin: 0; font-weight: 650; }
    .spacer { flex: 1; }
    .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(127,127,127,.35); background: rgba(127,127,127,.08); }
    input[type="search"] { padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(127,127,127,.35); min-width: 220px; }
    button { padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(127,127,127,.35); background: rgba(127,127,127,.08); cursor:pointer; }
    button:hover { background: rgba(127,127,127,.14); }
    #status { font-size: 12px; opacity: .9; }
    #wrap { height: calc(100vh - 58px); }
    svg { width: 100%; height: 100%; display:block; background: rgba(127,127,127,.04); }

    .link { stroke: rgba(127,127,127,.65); stroke-width: 1.2; }
    .node circle { stroke: rgba(0,0,0,.35); stroke-width: 1; }
    .node text { font-size: 11px; pointer-events: none; paint-order: stroke; stroke: rgba(0,0,0,.35); stroke-width: 3px; stroke-linejoin: round; }
    .node.dim { opacity: .15; }
    .link.dim { opacity: .08; }

    .tooltip {
      position: fixed; z-index: 9999;
      padding: 8px 10px; border-radius: 10px;
      background: rgba(20,20,20,.92); color: white;
      font-size: 12px; line-height: 1.25;
      max-width: 360px; pointer-events: none;
      transform: translate(10px, 10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      display:none;
    }
    .legend {
      position: fixed; right: 12px; top: 70px; z-index: 10;
      padding: 10px 10px; border-radius: 14px;
      border: 1px solid rgba(127,127,127,.35);
      background: rgba(255,255,255,.75);
      backdrop-filter: blur(10px);
      max-height: calc(100vh - 110px);
      overflow:auto;
      min-width: 180px;
    }
    @media (prefers-color-scheme: dark) {
      .legend { background: rgba(20,20,20,.65); }
    }
    .legend h2 { font-size: 12px; margin: 0 0 6px 0; opacity:.9; }
    .legend .row { display:flex; align-items:center; gap:8px; padding: 3px 0; font-size: 12px; }
    .swatch { width: 10px; height: 10px; border-radius: 999px; border: 1px solid rgba(0,0,0,.25); }
    .hint { font-size: 12px; opacity: .75; padding: 0 14px 10px 14px; }
  </style>

  <!-- Optional: if your Flask route passes data_url, it will be used first -->
  <script>
    // If you render this via Flask, you can pass `data_url` into the template:
    // return render_template("db_visualization.html", data_url=url_for("YOUR_DATA_ENDPOINT"))
    const DBVIZ_DATA_URL =
      (typeof {{ 'data_url'|tojson }} !== "undefined" ? {{ 'data_url'|tojson }} : null);
  </script>
</head>

<body>
  <header>
    <h1>Database Visualization</h1>
    <span class="pill" id="counts">Nodes: – | Edges: –</span>
    <span class="pill" id="endpoint">Endpoint: –</span>
    <span class="spacer"></span>

    <input id="search" type="search" placeholder="Filter by id / label / table…" />
    <button id="reset">Reset view</button>
    <button id="toggleLabels">Toggle labels</button>
    <span id="status"></span>
  </header>

  <div class="hint">
    Drag nodes • Scroll to zoom • Pan by dragging background • Hover nodes for details
  </div>

  <div id="wrap">
    <svg id="svg" role="img" aria-label="Database graph visualization"></svg>
  </div>

  <div class="legend" id="legend" style="display:none;">
    <h2>Tables</h2>
    <div id="legendRows"></div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    // ---- Robust D3 loader (fixes “failed to load” when CDN is blocked) ----
    async function loadScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = src;
        s.async = true;
        s.onload = resolve;
        s.onerror = () => reject(new Error("Failed to load script: " + src));
        document.head.appendChild(s);
      });
    }

    async function ensureD3() {
      if (window.d3) return;

      // Try CDN(s) first, then a local static fallback path (common in Flask projects)
      const candidates = [
        "https://d3js.org/d3.v7.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js",
        "/static/d3.v7.min.js",
        "/static/js/d3.v7.min.js",
        "/static/vendor/d3/d3.v7.min.js"
      ];

      let lastErr = null;
      for (const src of candidates) {
        try {
          await loadScript(src);
          if (window.d3) return;
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error("D3 failed to load.");
    }

    // ---- Data fetch that survives wrong endpoint names / login redirects ----
    async function fetchJson(url) {
      const res = await fetch(url, { credentials: "same-origin" });

      const contentType = (res.headers.get("content-type") || "").toLowerCase();
      const text = await res.text();

      if (!res.ok) {
        throw new Error(`HTTP ${res.status} from ${url}: ${text.slice(0, 200)}`);
      }

      // If you got redirected to a login page, you'll see HTML here
      if (text.trim().startsWith("<")) {
        throw new Error(
          `Got HTML (not JSON) from ${url}. This usually means the endpoint is protected and redirected to login.`
        );
      }

      try {
        return JSON.parse(text);
      } catch {
        throw new Error(`Response was not valid JSON from ${url}. Content-Type=${contentType}`);
      }
    }

    async function fetchFromAnyEndpoint() {
      const candidates = [];

      // If Flask injects data_url, try it first.
      if (DBVIZ_DATA_URL) candidates.push(DBVIZ_DATA_URL);

      // Common variations (hyphen vs underscore; folder-based routes)
      candidates.push(
        "/api/db-visualization",
        "/api/db_visualization",
        "/db_visualization/data",
        "/db_visualization/json",
        "api/db-visualization",
        "api/db_visualization",
        "db_visualization/data",
        "db_visualization/json"
      );

      const tried = [];
      let lastErr = null;

      for (const url of candidates) {
        if (!url || tried.includes(url)) continue;
        tried.push(url);
        try {
          const data = await fetchJson(url);
          return { data, url };
        } catch (e) {
          lastErr = e;
        }
      }

      throw lastErr || new Error("No endpoints worked: " + tried.join(", "));
    }

    // ---- Graph rendering ----
    function normalizeGraphPayload(payload) {
      // Accept either {nodes, links} OR {tree, links} OR {nodes, edges}
      if (payload && Array.isArray(payload.nodes)) {
        return {
          nodes: payload.nodes,
          links: payload.links || payload.edges || []
        };
      }
      if (payload && payload.tree && Array.isArray(payload.links)) {
        // If you returned a hierarchical tree but also have links, flatten tree to nodes
        const nodes = [];
        (function walk(n, parent=null) {
          if (!n) return;
          nodes.push(n);
          if (Array.isArray(n.children)) n.children.forEach(c => walk(c, n));
        })(payload.tree);
        return { nodes, links: payload.links };
      }
      throw new Error("Unexpected payload shape. Expected {nodes:[…], links:[…]} (or {tree,…}).");
    }

    function nodeId(n) {
      // Prefer a stable unique id
      return n.uid ?? n.id ?? n.pk ?? n.key ?? n.name ?? JSON.stringify(n);
    }

    function nodeLabel(n) {
      // Friendly label
      return n.label ?? n.name ?? String(nodeId(n));
    }

    function nodeTable(n) {
      return n.table ?? n.entity ?? n.type ?? "unknown";
    }

    (async function main() {
      const statusEl = document.getElementById("status");
      const endpointEl = document.getElementById("endpoint");
      const countsEl = document.getElementById("counts");
      const svgEl = document.getElementById("svg");
      const tooltipEl = document.getElementById("tooltip");
      const legendEl = document.getElementById("legend");
      const legendRowsEl = document.getElementById("legendRows");
      const searchEl = document.getElementById("search");
      const resetBtn = document.getElementById("reset");
      const toggleLabelsBtn = document.getElementById("toggleLabels");

      const setStatus = (msg) => { statusEl.textContent = msg || ""; };

      try {
        setStatus("Loading D3…");
        await ensureD3();

        setStatus("Loading graph data…");
        const { data: raw, url: usedEndpoint } = await fetchFromAnyEndpoint();
        endpointEl.textContent = "Endpoint: " + usedEndpoint;

        const { nodes: rawNodes, links: rawLinks } = normalizeGraphPayload(raw);

        // Build a stable node map
        const nodes = rawNodes.map(n => ({
          ...n,
          __id: nodeId(n),
          __label: nodeLabel(n),
          __table: nodeTable(n)
        }));

        const byId = new Map(nodes.map(n => [n.__id, n]));

        // Normalize links: allow {source,target} as ids or objects
        const links = (rawLinks || []).map(l => {
          const s = (typeof l.source === "object" && l.source) ? (l.source.__id ?? nodeId(l.source)) : l.source;
          const t = (typeof l.target === "object" && l.target) ? (l.target.__id ?? nodeId(l.target)) : l.target;

          return {
            ...l,
            source: byId.get(s) ? s : s,
            target: byId.get(t) ? t : t
          };
        }).filter(l => byId.has(l.source) && byId.has(l.target));

        countsEl.textContent = `Nodes: ${nodes.length} | Edges: ${links.length}`;

        // Table color scale + legend
        const tables = Array.from(new Set(nodes.map(n => n.__table))).sort();
        const color = d3.scaleOrdinal(tables, d3.schemeTableau10.concat(d3.schemeSet3 || []));

        legendRowsEl.innerHTML = "";
        for (const t of tables) {
          const row = document.createElement("div");
          row.className = "row";
          const sw = document.createElement("span");
          sw.className = "swatch";
          sw.style.background = color(t);
          const name = document.createElement("span");
          name.textContent = t;
          row.appendChild(sw);
          row.appendChild(name);
          legendRowsEl.appendChild(row);
        }
        legendEl.style.display = tables.length ? "block" : "none";

        // SVG setup
        const svg = d3.select(svgEl);
        svg.selectAll("*").remove();

        const { width, height } = svgEl.getBoundingClientRect();

        const zoomLayer = svg.append("g").attr("class", "zoom-layer");
        const linkLayer = zoomLayer.append("g").attr("class", "links");
        const nodeLayer = zoomLayer.append("g").attr("class", "nodes");
        const labelLayer = zoomLayer.append("g").attr("class", "labels");

        const zoom = d3.zoom()
          .scaleExtent([0.1, 6])
          .on("zoom", (event) => zoomLayer.attr("transform", event.transform));

        svg.call(zoom);

        // Force simulation
        const simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d => d.__id).distance(50).strength(0.5))
          .force("charge", d3.forceManyBody().strength(-140))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collide", d3.forceCollide().radius(d => 10).strength(0.8));

        const linkSel = linkLayer.selectAll("line")
          .data(links)
          .enter()
          .append("line")
          .attr("class", "link");

        const nodeSel = nodeLayer.selectAll("g")
          .data(nodes)
          .enter()
          .append("g")
          .attr("class", "node")
          .call(
            d3.drag()
              .on("start", (event, d) => {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
              })
              .on("drag", (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
              })
              .on("end", (event, d) => {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
              })
          );

        nodeSel.append("circle")
          .attr("r", 7)
          .attr("fill", d => color(d.__table));

        let labelsVisible = true;

        const labelSel = labelLayer.selectAll("text")
          .data(nodes)
          .enter()
          .append("text")
          .text(d => d.__label)
          .style("display", labelsVisible ? "block" : "none");

        // Tooltip + hover highlighting
        function showTooltip(event, d) {
          tooltipEl.style.display = "block";
          tooltipEl.textContent = `${d.__table}: ${d.__label} (${d.__id})`;
          moveTooltip(event);
        }
        function moveTooltip(event) {
          tooltipEl.style.left = `${event.clientX}px`;
          tooltipEl.style.top = `${event.clientY}px`;
        }
        function hideTooltip() {
          tooltipEl.style.display = "none";
        }

        // Build adjacency for fast highlight
        const neighbor = new Map();
        for (const n of nodes) neighbor.set(n.__id, new Set([n.__id]));
        for (const l of links) {
          neighbor.get(l.source).add(l.target);
          neighbor.get(l.target).add(l.source);
        }

        nodeSel
          .on("mouseenter", (event, d) => {
            showTooltip(event, d);
            const nset = neighbor.get(d.__id) || new Set([d.__id]);
            nodeSel.classed("dim", x => !nset.has(x.__id));
            labelSel.classed("dim", x => !nset.has(x.__id));
            linkSel.classed("dim", l => !(l.source.__id ? nset.has(l.source.__id) : nset.has(l.source)) ||
                                       !(l.target.__id ? nset.has(l.target.__id) : nset.has(l.target)));
          })
          .on("mousemove", (event) => moveTooltip(event))
          .on("mouseleave", () => {
            hideTooltip();
            nodeSel.classed("dim", false);
            labelSel.classed("dim", false);
            linkSel.classed("dim", false);
          });

        // Search filter
        function applyFilter(query) {
          const q = (query || "").trim().toLowerCase();
          if (!q) {
            nodeSel.classed("dim", false);
            labelSel.classed("dim", false);
            linkSel.classed("dim", false);
            return;
          }
          const keep = new Set(
            nodes
              .filter(n =>
                n.__id.toLowerCase().includes(q) ||
                n.__label.toLowerCase().includes(q) ||
                n.__table.toLowerCase().includes(q)
              )
              .map(n => n.__id)
          );

          nodeSel.classed("dim", d => !keep.has(d.__id));
          labelSel.classed("dim", d => !keep.has(d.__id));
          linkSel.classed("dim", l => !(keep.has(l.source.__id || l.source) && keep.has(l.target.__id || l.target)));
        }

        searchEl.addEventListener("input", () => applyFilter(searchEl.value));

        // Controls
        resetBtn.addEventListener("click", () => {
          svg.transition().duration(250).call(zoom.transform, d3.zoomIdentity);
          searchEl.value = "";
          applyFilter("");
        });

        toggleLabelsBtn.addEventListener("click", () => {
          labelsVisible = !labelsVisible;
          labelSel.style("display", labelsVisible ? "block" : "none");
        });

        // Tick update
        simulation.on("tick", () => {
          linkSel
            .attr("x1", d => (d.source.x ?? 0))
            .attr("y1", d => (d.source.y ?? 0))
            .attr("x2", d => (d.target.x ?? 0))
            .attr("y2", d => (d.target.y ?? 0));

          nodeSel.attr("transform", d => `translate(${d.x ?? 0},${d.y ?? 0})`);

          labelSel
            .attr("x", d => (d.x ?? 0) + 10)
            .attr("y", d => (d.y ?? 0) + 4);
        });

        setStatus("Loaded.");
      } catch (err) {
        console.error(err);
        setStatus("Failed to load: " + (err && err.message ? err.message : String(err)));

        // Helpful hint directly on the page
        const hint = document.createElement("div");
        hint.style.padding = "10px 14px";
        hint.style.fontSize = "12px";
        hint.style.opacity = ".85";
        hint.innerHTML =
          "<b>Troubleshooting:</b> Open DevTools → Console/Network. " +
          "If the data request returns HTML, your JSON endpoint is likely redirecting to login " +
          "(protect the page, but allow the JSON endpoint), or the URL is wrong.";
        document.body.insertBefore(hint, document.getElementById("wrap"));
      }
    })();
  </script>
</body>
</html>
