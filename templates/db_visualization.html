<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Lernlandkarte - Motivation und Emotionen</title>
  <style>
    body {
      margin: 0;
      background: #ffffff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
                   "Segoe UI", sans-serif;
    }

    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    #controls {
      position: fixed;
      top: 12px;
      left: 16px;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 999px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      font-size: 13px;
      z-index: 10;
    }

    #controls input[type=range] {
      vertical-align: middle;
    }

    svg {
      width: 900px;
      height: 900px;
    }

    .links path {
      fill: none;
      stroke: #bbbbbb;
      stroke-width: 0.6px;
      stroke-opacity: 0.25;
      pointer-events: none;
    }

    .links path.highlight {
      stroke-width: 1.6px;
      stroke-opacity: 0.95;
    }

    .links path.faded {
      stroke-opacity: 0.04;
    }

    .links path.outgoing {
      stroke: #d73027; /* red-ish */
    }

    .links path.incoming {
      stroke: #1a9850; /* green-ish */
    }

    .labels text {
      font-size: 9px;
      cursor: default;
    }

    .labels text.faded {
      fill-opacity: 0.25;
    }

    .group-arcs path {
      pointer-events: none;
    }

    /* Floating hover image for the current node */
    #node-image {
      position: fixed;
      width: 260px;       /* tweak as you like */
      height: 180px;      /* tweak as you like */
      object-fit: contain;
      background: rgba(255, 255, 255, 0.98);
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.35);
      display: none;      /* shown on hover */
      pointer-events: none; /* don't capture mouse; keep hover on label */
      z-index: 30;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="controls">
      <!--
      Bundling strength β:
      <input id="beta-slider" type="range" min="0" max="1" step="0.05" value="0.75">
      <span id="beta-value">0.75</span>-->
    </div>
    <svg id="chart"></svg>
  </div>

  <!-- Floating image that appears near the hovered label -->
  <img id="node-image" src="" alt="Node image">

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // --- Layout parameters ---
    const width = 900;
    const height = 900;
    const radius = Math.min(width, height) / 2;
    let beta = 0.75;

    const svg = d3.select("#chart")
      .attr("viewBox", [-width / 2, -height / 2, width, height]);
    const rim = 250;
    const cluster = d3.cluster()
      .size([2 * Math.PI, radius - rim]);

    const nodeImage = document.getElementById("node-image");

    // --- Synthetic data: hierarchy + imports ---------------------------------

    const groups = [];
    const leavesPerGroup = 10;

    const data = [];
    for (const g of groups) {
      for (let i = 0; i < leavesPerGroup; ++i) {
        data.push({
          name: `root.${g}.${g}${i}`,
          imports: []
        });
      }
    }

    data.push({ name: "root.Folien.Intelligenz",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Collins, Brown & Newman (1989)",
     "root.Folien.Erfolgreich Lernende"
     ] });

    data.push({ name: "root.Folien.Motivation",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Collins, Brown & Newman (1989)",
     "root.Folien.Erfolgreich Lernende"
     ] });


    data.push({ name: "root.Folien.Intrinsische Motivation",
     imports: ["root.Foliensatz.Foliensatz 06",
     "root.Folien.Motivation"

     ] });

    data.push({ name: "root.Folien.Extrinsische Motivation",
     imports: ["root.Foliensatz.Foliensatz 06",
     "root.Folien.Motivation"
     ] });
    
    
         data.push({ name: "root.Folien.Selbstregulation",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Collins, Brown & Newman (1989)",
     "root.Folien.Erfolgreich Lernende"
     ] });

         data.push({ name: "root.Folien.Aufmerksamkeit/Konzentration",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Collins, Brown & Newman (1989)",
     "root.Folien.Erfolgreich Lernende"
     ] });

         data.push({ name: "root.Folien.Mindset/Überzeugungen",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Collins, Brown & Newman (1989)",
     "root.Folien.Erfolgreich Lernende",
     "root.Quellen.Jansen und Möller et al (2022)"
     ] });

         data.push({ name: "root.Folien.Emotionen",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Collins, Brown & Newman (1989)",
     "root.Folien.Erfolgreich Lernende"
     ] });
         data.push({ name: "root.Folien.Leistung",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Jansen und Möller et al (2022)"
     ] });

         data.push({ name: "root.Folien.Sozioemotionale Variablen",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Jansen und Möller et al (2022)"
     ] });

    data.push({ name: "root.Folien.Sozioemotionale Variablen",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Jansen und Möller et al (2022)"
     ] });

    data.push({ name: "root.Folien.Lehrperson",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Jansen und Möller et al (2022)"
     ] });


      data.push({ name: "root.Folien.Selbstwirksamkeitstheorie",
     imports: ["root.Foliensatz.Foliensatz 05",
     "root.Quellen.Jansen und Möller et al (2022)"
     ] });

        data.push({ name: "root.Folien.Formen der Motivation",
     imports: ["root.Foliensatz.Foliensatz 06",
     "root.Folien.Extrinsische Motivation",
     "root.Folien.Intrinsische Motivation",
     "root.Folien.Motivation"
     ] });

        data.push({ name: "root.Folien.Formen der Motivation",
     imports: ["root.Foliensatz.Foliensatz 06",
     "root.Folien.Extrinsische Motivation",
     "root.Folien.Intrinsische Motivation",
     "root.Folien.Motivation",
     "root.Quellen.Grassinger et al (2019)"
     ] });

        data.push({ name: "root.Folien.Selbstbestimmungstheorie",
     imports: ["root.Foliensatz.Foliensatz 06",
     "root.Quellen.Deci & Ryan (1993)",
     "root.Quellen.Ryan & Deci (2020)",
     "root.Quellen.Woolfolk (2014)"
    
     ] });

        data.push({ name: "root.Folien.Attributionstheorie",
     imports: ["root.Foliensatz.Foliensatz 06",
     "root.Quellen.Deci & Ryan (1993)",
     "root.Quellen.Ryan & Deci (2020)",
     "root.Quellen.Woolfolk (2014)",
     "root.Quellen.Weiner (1986)"
     ] });

        data.push({ name: "root.Folien.Feedback",
     imports: ["root.Foliensatz.Foliensatz 06",
     "root.Quellen.Hattie & Timperley (2007)"
     ] });


        data.push({ name: "root.Folien.Feedbackloop zur Lern- und Motivationsförderung",
     imports: ["root.Foliensatz.Foliensatz 06",
     "root.Quellen.Hattie & Timperley (2007)",
     "root.Folien.Feedback"
     ] });

             data.push({ name: "root.Folien.DON'Ts zu Motivation und Feedback",
     imports: ["root.Foliensatz.Foliensatz 06",
     "root.Folien.Feedback",
     "root.Quellen.Müller et al (2009)",
     "root.Quellen.Prenzel (1997)"

     ] });

      data.push({ name: "root.Folien.Emotionen",
     imports: ["root.Foliensatz.Foliensatz 07",
     ] });

      data.push({ name: "root.Folien.Basisemotionen",
     imports: ["root.Foliensatz.Foliensatz 07",
     "root.Folien.Emotionen"
     ] });

     
      data.push({ name: "root.Folien.Affektiver Kern",
     imports: ["root.Foliensatz.Foliensatz 07",
     "root.Folien.Emotionen",
     "root.Quellen.Frenzel & Stephens (2017)"
     ] });

      data.push({ name: "root.Folien.Expressive Komponente",
     imports: ["root.Foliensatz.Foliensatz 07",
     "root.Folien.Emotionen",
     "root.Quellen.Frenzel & Stephens (2017)"
     ] });

      data.push({ name: "root.Folien.Kognitive Komponente",
     imports: ["root.Foliensatz.Foliensatz 07",
     "root.Folien.Emotionen",
     "root.Quellen.Frenzel & Stephens (2017)"
     ] });

      data.push({ name: "root.Folien.Physiologische Komponente",
     imports: ["root.Foliensatz.Foliensatz 07",
     "root.Folien.Emotionen",
     "root.Quellen.Frenzel & Stephens (2017)"
     ] });


      data.push({ name: "root.Folien.Motivationale Komponente",
     imports: ["root.Foliensatz.Foliensatz 07",
     "root.Folien.Emotionen",
     "root.Quellen.Frenzel & Stephens (2017)"
     ] });

        data.push({ name: "root.Folien.Leistungsemotionen",
     imports: ["root.Foliensatz.Foliensatz 07",
     "root.Folien.Emotionen",
     "root.Folien.Motivation",
     "root.Quellen.Götz et al (2007)",
     "root.Quellen.Pekrun & Frenzel (2009)",
     "root.Quellen.Pekrun (2006)"
     ] });

        data.push({ name: "root.Folien.Appraisaltheorie",
     imports: ["root.Foliensatz.Foliensatz 07",
    "root.Folien.Leistungsemotionen",
     "root.Folien.Motivation",
     "root.Quellen.Götz et al (2025)",
     "root.Quellen.Pekrun (2006)",
     "root.Quellen.Pekrun (2017)"
     ] });

          data.push({ name: "root.Folien.Langeweile",
     imports: ["root.Foliensatz.Foliensatz 07",
     "root.Quellen.Götz et al (2007)",
     "root.Quellen.Macklem (2015)",
     "root.Quellen.Nett et al (2011)",
     "root.Quellen.Schwatze et al (2020)",
     "root.Folien.Emotionen"

     ] });

      data.push({ name: "root.Folien.Prüfungsangst",
     imports: ["root.Foliensatz.Foliensatz 07",
     "root.Quellen.Frenzel (2007)",
     "root.Folien.Stress"
     ] });

      data.push({ name: "root.Folien.Emotionale Kompetenzen",
     imports: ["root.Foliensatz.Foliensatz 07",
  "root.Quellen.Eckert et al (2016)",
  "root.Quellen.Harley et al (2019)",
  "root.Quellen.Frenzel et al (2020)",
  "root.Quellen.Saarni (2002)",
     "root.Folien.Stress"
     ] });

      data.push({ name: "root.Folien.Emotionen bei Lehrpersonen",
     imports: ["root.Foliensatz.Foliensatz 07",
"root.Quellen.Götz et al (2025)",
"root.Folien.Emotionen",
"root.Quellen.Frenzel et al (2018)",
"root.Quellen.Rubach et al (2023)",
"root.Quellen.Hascher & Hagenauer (2011)",
     ] });

  data.push({ name: "root.Quellen.Hascher & Hagenauer (2011)", imports: [] });

  data.push({ name: "root.Quellen.Rubach et al (2023)", imports: [] });
  data.push({ name: "root.Quellen.Harley et al (2019)", imports: [] });
  data.push({ name: "root.Quellen.Saarni (2002)", imports: [] });

  data.push({ name: "root.Quellen.Harley et al (2019)", imports: [] });
  data.push({ name: "root.Quellen.Saarni (2002)", imports: [] });

  data.push({ name: "root.Quellen.Eckert et al (2016)", imports: [] });
  data.push({ name: "root.Quellen.Frenzel et al (2020)", imports: [] });

  data.push({ name: "root.Quellen.Frenzel et al (2018)", imports: [] });

  data.push({ name: "root.Quellen.Macklem (2015)", imports: [] });
  data.push({ name: "root.Quellen.Nett et al (2011)", imports: [] });
  data.push({ name: "root.Quellen.Schwatze et al (2020)", imports: [] });

  data.push({ name: "root.Quellen.Götz et al (2025)", imports: [] });

  data.push({ name: "root.Quellen.Götz et al (2007)", imports: [] });
  data.push({ name: "root.Quellen.Pekrun (2006)", imports: [] });
  data.push({ name: "root.Quellen.Pekrun (2017)", imports: [] });

  data.push({ name: "root.Quellen.Pekrun & Frenzel (2009)", imports: [] });
  data.push({ name: "root.Quellen.Frenzel (2007)", imports: [] });

  data.push({ name: "root.Quellen.Frenzel & Stephens (2017)", imports: [] });

  data.push({ name: "root.Quellen.Müller et al (2009)", imports: [] });
  data.push({ name: "root.Quellen.Prenzel (1997)", imports: [] });

  data.push({ name: "root.Quellen.Weiner (1986)", imports: [] });
  data.push({ name: "root.Quellen.Hattie & Timperley (2007)", imports: [] });

  data.push({ name: "root.Quellen.Woolfolk (2014)", imports: [] });
  data.push({ name: "root.Quellen.Deci & Ryan (1993)", imports: [] });
  data.push({ name: "root.Quellen.Ryan & Deci (2020)", imports: [] });

  data.push({ name: "root.Quellen.Grassinger et al (2019)", imports: [] });
  data.push({ name: "root.Quellen.Jansen und Möller et al (2022)", imports: [] });
  data.push({ name: "root.Quellen.Collins, Brown & Newman (1989)"  , imports: []});
  data.push({ name: "root.Foliensatz.Foliensatz 05", imports: []});
  data.push({ name: "root.Foliensatz.Foliensatz 06", imports: []});
  data.push({ name: "root.Foliensatz.Foliensatz 07", imports: []});



    const allNames = data.map(d => d.name);

    // Deterministic pseudo-random for reproducibility
    let seed = 7;
    function rand() {
      seed = (seed * 16807) % 2147483647;
      return (seed - 1) / 2147483646;
    }

    // For each leaf, connect it to a few others
    data.forEach(d => {
      const k = 3 + Math.floor(rand() * 4); // 3..6 imports
      const targets = new Set();
      while (targets.size < k) {
        const t = allNames[Math.floor(rand() * allNames.length)];
        if (t !== d.name) targets.add(t);
      }
      //d.imports = Array.from(targets);
    });

    // --- Build hierarchy from dot-separated names -----------------------------

    function buildHierarchy(classes) {
      const map = new Map();

      function find(name) {
        if (map.has(name)) return map.get(name);
        const node = { name: name, children: [] };
        map.set(name, node);
        if (name !== "root") {
          const i = name.lastIndexOf(".");
          const parentName = i >= 0 ? name.substring(0, i) : "root";
          const parent = find(parentName);
          parent.children.push(node);
        }
        return node;
      }

      classes.forEach(d => {
        const node = find(d.name);
        node.imports = d.imports || [];
      });

      return d3.hierarchy(find("root"));
    }

    const root = buildHierarchy(data);
    cluster(root);

    const leaves = root.leaves();
    const nodeByName = new Map(leaves.map(d => [d.data.name, d]));

    // Helper: extract group from node name "root.Group.Leaf"
    function groupOf(node) {
      const parts = node.data.name.split(".");
      return parts.length >= 3 ? parts[1] : "Other";
    }

    // --- Group color scale ----------------------------------------------------

    const groupLeaves = d3.groups(leaves, d => groupOf(d));
    const groupNames = groupLeaves.map(d => d[0]);

    const color = d3.scaleOrdinal()
      .domain(groupNames)
      .range([
        "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728",
        "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
        "#bcbd22", "#17becf"
      ]);


    // Add your function here:
    function imageForNode(name) {
      switch (name) {
        case "root.Folien.Test": return "images/selbstwirksamkeit.png";

        default: return None;
      }
    }

    // --- Build edges from imports --------------------------------------------

    const edges = [];
    data.forEach(d => {
      const source = nodeByName.get(d.name);
      if (!source) return;
      (d.imports || []).forEach(t => {
        const target = nodeByName.get(t);
        if (!target) return;
        edges.push({ source, target });
      });
    });

    // Precompute hierarchical path between source and target for each edge
    edges.forEach(e => {
      e.path = e.source.path(e.target);
    });

    // --- Radial bundle line ---------------------------------------------------

    let line = d3.lineRadial()
      .curve(d3.curveBundle.beta(beta))
      .radius(d => d.y)
      .angle(d => d.x);

    // --- Draw links -----------------------------------------------------------

    const linksGroup = svg.append("g").attr("class", "links");

    const link = linksGroup.selectAll("path")
      .data(edges)
      .join("path")
      .attr("d", d => line(d.path));

    // --- Group arcs (between edges and labels) -------------------------------

    const leafRadius = d3.max(leaves, d => d.y);

    // Arcs just outside the edge endpoints, but inside the labels
    const groupArc = d3.arc()
      .innerRadius(leafRadius + 2)   // just outside where edges end
      .outerRadius(leafRadius + 6);  // below the labels

    const arcsGroup = svg.append("g").attr("class", "group-arcs");

    arcsGroup.selectAll("path")
      .data(groupLeaves)
      .join("path")
      .attr("d", ([g, nodes]) => {
        const startAngle = d3.min(nodes, n => n.x);
        const endAngle   = d3.max(nodes, n => n.x);
        return groupArc({ startAngle, endAngle });
      })
      .attr("fill", ([g]) => color(g))
      .attr("fill-opacity", 0.35)
      .attr("stroke", ([g]) => color(g))
      .attr("stroke-width", 1.0);

    // --- Draw leaf labels -----------------------------------------------------

    const labelsGroup = svg.append("g").attr("class", "labels");

    const label = labelsGroup.selectAll("text")
      .data(leaves)
      .join("text")
      .attr("dy", "0.31em")
      .attr("transform", d => {
        const angle = d.x - Math.PI / 2;
        const rotate = `rotate(${angle * 180 / Math.PI})`;
        // push labels further out so arcs fit under them
        const translate = `translate(${d.y + 12},0)`;
        const flip = d.x >= Math.PI ? "rotate(180)" : "";
        return [rotate, translate, flip].join(" ");
      })
      .attr("text-anchor", d => (d.x < Math.PI ? "start" : "end"))
      .attr("fill", d => color(groupOf(d)))
      .text(d => d.data.name.split(".").slice(-1)[0]);

    // --- Precompute incoming/outgoing edge sets per node ---------------------

    const outgoing = new Map();
    const incoming = new Map();

    edges.forEach(e => {
      const s = e.source.data.name;
      const t = e.target.data.name;
      if (!outgoing.has(s)) outgoing.set(s, []);
      if (!incoming.has(t)) incoming.set(t, []);
      outgoing.get(s).push(e);
      incoming.get(t).push(e);
    });

    // --- Hover: highlight bundles + show floating image ----------------------

    label
      .on("mouseover", (event, d) => {
        const name = d.data.name;
        const out = outgoing.get(name) || [];
        const inc = incoming.get(name) || [];

        // Edge highlight
        link
          .classed("highlight", e => out.includes(e) || inc.includes(e))
          .classed("faded", e => !(out.includes(e) || inc.includes(e)))
          .classed("outgoing", e => out.includes(e))
          .classed("incoming", e => inc.includes(e));

        label.classed("faded", n => n !== d);

        // --- Position image: one corner touching the label -------------------
        const labelBox = event.target.getBoundingClientRect();
        const imgWidth = nodeImage.offsetWidth || 260;
        const imgHeight = nodeImage.offsetHeight || 180;

        // Start: top-left of image at right-middle of label
        let left = labelBox.right + 8;
        let top = labelBox.top + (labelBox.height / 2) - (imgHeight / 2);

        // Keep image on-screen (basic clamping)
        left = Math.min(Math.max(left, 4), window.innerWidth - imgWidth - 4);
        top = Math.min(Math.max(top, 4), window.innerHeight - imgHeight - 4);

        nodeImage.style.left = `${left}px`;
        nodeImage.style.top = `${top}px`;

        // Set the image source based on the node
        nodeImage.src = imageForNode(name);
        nodeImage.style.display = "block";
      })
      .on("mouseout", () => {
        // Reset edges & labels
        link
          .classed("highlight", false)
          .classed("faded", false)
          .classed("incoming", false)
          .classed("outgoing", false);

        label.classed("faded", false);

        // Hide image
        nodeImage.style.display = "none";
      });

    // --- Slider for bundling strength β --------------------------------------

    const slider = document.getElementById("beta-slider");
    const betaSpan = document.getElementById("beta-value");

    slider.addEventListener("input", function () {
      beta = parseFloat(this.value);
      betaSpan.textContent = beta.toFixed(2);
      line.curve(d3.curveBundle.beta(beta));
      link.attr("d", d => line(d.path));
    });

    betaSpan.textContent = beta.toFixed(2);
  </script>
</body>
</html>

